<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>Atom</title>
  <style>
  	html, body {
			color: lightgray;
			width: 100%;
			height: 100%;
			font-family: sans-serif;
		  margin: 0;
		  overflow: hidden;
		  background-color: black;
		}

		#author {
			color: #888;
			width: 100%;
			text-align: right;
			position: absolute;
			bottom: 0.5em;
			right: 0.5em;
		}

		#author a {
			color: #888;
			text-decoration: underline;
		}

		#container {
			width: 100%;
			height: 100%;
		}

		#loading, #controls-info {
		  position: absolute;
		  text-align: center;
		  width: 100%;
		  font-size: 2em;
		  text-transform: uppercase;
		  font-weight: 100;
		}

		#loading {
			top: 50%;
		}

		#controls-info {
			bottom: 10%;
		}

		#controls {
			padding: 2em;
		  display: block;
		  background-color: rgba(0, 0, 0, 0.2);
		  position: absolute;
		}

		#controls label {
			display: block;
			white-space: nowrap;
			width: 400px;
			margin-bottom: 0.3em;
		}

		#controls input {
			width: 100%;
		}
  </style>
</head>

<body>
	<div id="container">
		<div id="loading">Loading...</div>
		<div id="controls-info" style="display: none">
			Click to open controls
		</div>

		<div id="controls" style="display: none"></div>
		<canvas id="scene"></canvas>
		<div id="author">
			Made by <a href="https://github.com/dmitru">Dmitriy Borodiy</a>
		</div>	
	</div>

	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.19.0/TweenMax.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.15.0/lodash.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

  <script>
  	var ww, wh, renderer, scene, camera, world, material, controls;

		var Config = {
		  LAYERS: { min: 1, max: 10, step: 1, value: 3 },

		  N: { min: 10, max: 1500, step: 10, value: 200 },

		  RADIUS: { min: 10, max: 500, step: 10, value: 220 },
		  RADIUS_POWER: { min: 0.1, max: 3, step: 0.01, value: 0.88 },
		  RADIUS_VARIABILITY: { min: 0.00, max: 2.0, step: 0.005, value: 0.185 },
		  RADIUS_VARIABILITY_POWER: { min: 0.2, max: 4.0, step: 0.005, value: 1.485 },

		  OPACITY: { min: 0.01, max: 1.0, step: 0.01, value: 0.15 },
		  OPACITY_VARIABILITY: { min: 0.00, max: 2.0, step: 0.01, value: 0.2 },
		  OPACITY_PULSE_PERIOD: { min: 0.1, max: 10, step: 0.01, value: 2.4 },
		  OPACITY_PULSE_DEPTH: { min: 0.00, max: 1.0, step: 0.01, value: 0.1 },

		  PULSE_DEPTH: { min: 0.00, max: 1.0, step: 0.001, value: 0.015 },
		  PULSE_PERIOD: { min: 0.00, max: 20.0, step: 0.01, value: 10 },
		  PULSE_VARIABILITY: { min: 0.00, max: 2.0, step: 0.01, value: 0.0 },

		  ROTATION: { min: 0, max: 0.005, step: 0.00005, value: 0.001 },

		  JITTER_PROBABILITY: { min: 0, max: 1.0, step: 0.01, value: 0 },
		  JITTER_INTENSITY: { min: 0, max: 1.0, step: 0.01, value: 0 },
		};

		function buildLayerConfigs(Config) {
		  const layerConfigs = [];
		  for (var layerIndex = 1; layerIndex <= Config.LAYERS.max; layerIndex += 1) {
		    layerConfigs.push({
		      rotX: layerIndex * Config.ROTATION.value * (layerIndex % 2 === 0 ? 1 : -1),
		      rotY: layerIndex * Config.ROTATION.value * (layerIndex % 2 === 0 ? 1 : -1),
		      rotZ: layerIndex * Config.ROTATION.value * (layerIndex % 2 === 0 ? 1 : -1),

		      n: Config.N.value,

		      radius: Config.RADIUS.value / Math.pow(layerIndex, Config.RADIUS_POWER.value),
		      radiusVariability: Config.RADIUS_VARIABILITY.value / layerIndex,
		      radiusVariabilityPower: Config.RADIUS_VARIABILITY_POWER.value,
		    });
		  }
		  return layerConfigs;
		}

		var layerConfigs = buildLayerConfigs(Config);

		function recreateScene() {
		  layerConfigs = buildLayerConfigs(Config);
		  scene.remove(world);
		  world = createWorld();
		  scene.add(world);
		}

		function initInputs() {
		  controls = $('#controls');
		  controls.click(function(e) { e.stopPropagation(); });
		  $(document).click(function(e) {
		      if (controls.css('display') === 'none') {
		        controls.css({ opacity: 0, display: 'block' })
		          .animate({ opacity: 1 }, 150);
		      } else {
		        controls.animate({ opacity: 0 }, 150);
		        setTimeout(function() { controls.css({ display: 'none' }); }, 150)
		      }
		  });

		  _.keys(Config).map(function(key) {
		    const keyConfig = Config[key];
		    console.log(key, keyConfig);

		    const label = $('<label>'); 
		    const input = $('<input>')
		      .attr(keyConfig)
		      .attr('type', 'range')
		      .on('change', function(e) {
		        const value = parseFloat(e.target.value);
		        console.log(key + ' = ' + value);
		        Config[key].value = value;
		        recreateScene();
		        window.location.hash = encodeConfig(Config);
		      });
		    label.append($('<div>').text(key));
		    label.append(input);
		    controls.append(label);
		  });
		}

		function init() {
		  ww = window.innerWidth;
		  wh = window.innerHeight;

		  renderer = new THREE.WebGLRenderer({
		    canvas: document.getElementById("scene"),
		    antialias: true,
		  });
		  renderer.setSize(ww, wh);
		  renderer.setClearColor('black');
		  renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1);

		  scene = new THREE.Scene();

		  camera = new THREE.PerspectiveCamera(50, ww / wh, 20, 10000);
		  camera.position.set(0, 0, 600);
		  scene.add(camera);

		  world = createWorld();
		  scene.add(world);

		  requestAnimationFrame(render);
		  window.addEventListener("resize", onWindowResize);

		  initInputs();
		}

		function onWindowResize() {
		  ww = window.innerWidth;
		  wh = window.innerHeight;

		  camera.aspect = ww / wh;
		  camera.updateProjectionMatrix();

		  renderer.setSize(ww, wh);
		}

		function createWorld() {
		  function createEllipse({ material, radius, rotX, rotY, rotZ }) {
		    var curve = new THREE.EllipseCurve(
		      0,  0,            // ax, aY
		      radius, radius,   // xRadius, yRadius
		      0,  2 * Math.PI,  // aStartAngle, aEndAngle
		      false,            // aClockwise
		      0                 // aRotation 
		    );

		    var path = new THREE.Path(curve.getPoints(20));
		    var geometry = path.createPointsGeometry(20);
		    _.forEach(geometry.vertices, function(v) { 
		      v.xOriginal = v.x;
		      v.yOriginal = v.y;
		      v.zOriginal = v.z;
		    });

		    // Create the final Object3d to add to the scene
		    var ellipse = new THREE.Line(geometry, material);
		    ellipse.geometry.verticesNeedUpdate = true;
		    ellipse.rotation.x = rotX;
		    ellipse.rotation.y = rotY;
		    ellipse.rotation.z = rotZ;

		    return ellipse;
		  }

		  function createLayer({ 
		    material, n, radius, radiusVariability, radiusVariabilityPower 
		  }) {
		    const sphere = new THREE.Object3D();
		    for (var i = 0; i < Config.N.value; ++i) {
		      const rotX = 2 * (Math.random() - 0.5) * Math.PI;
		      const rotY = 2 * (Math.random() - 0.5) * Math.PI;
		      const rotZ = 2 * (Math.random() - 0.5) * Math.PI;
		      const r = radius + 
		        Math.pow(radius * radiusVariability * Math.random(), radiusVariabilityPower) * 
		        (Math.random() > 0.5 ? 1 : -1);
		      sphere.add(createEllipse({ material, radius: r, rotX, rotY, rotZ }));
		    }

		    return sphere;
		  }

		  material = new THREE.MeshBasicMaterial({ 
		    color: 'white',
		    fog: true,
		    opacity: Config.OPACITY.value,
		    transparent: true, 
		    depthWrite: false,
		  });
		  const maxOpacity = Config.OPACITY.value * 
		    (1.0 + Config.OPACITY_PULSE_DEPTH.value + Math.random() * Config.OPACITY_VARIABILITY.value);
		  TweenMax.to(material, Config.OPACITY_PULSE_PERIOD.value, {
		    opacity: maxOpacity,
		    repeat: -1,
		    yoyo: true,
		    ease: Power2.easeIn,
		  });

		  world = new THREE.Object3D();
		  for (var layerIndex = 0; layerIndex < Config.LAYERS.value; ++layerIndex) {
		    const layerConfig = layerConfigs[layerIndex];
		    const layer = createLayer(Object.assign({ material }, layerConfig));

		    const pulsePeriod = Config.PULSE_PERIOD.value * 
		      (1.0 + Math.random() * Config.PULSE_VARIABILITY.value);
		    const pulseDepth = Config.PULSE_DEPTH.value * 
		      (1.0 + Math.random() * Config.PULSE_VARIABILITY.value);
		    layer.scaleFactor = 0.0;
		    TweenMax.to(layer, pulsePeriod, {
		      scaleFactor: pulseDepth,
		      repeat: -1,
		      yoyo: true,
		      ease: Power3.easeIn,
		    });

		    world.add(layer);  
		  }

		  return world;
		}

		function render() {
		  requestAnimationFrame(render);

		  _.forEach(world.children, function(layer, index) {
		    const layerConfig = layerConfigs[index];
		    layer.rotation.x += layerConfig.rotX;
		    layer.rotation.y += layerConfig.rotY;
		    layer.rotation.z += layerConfig.rotZ;

		    layer.scale.set(
		      1.0 * (1.0 + layer.scaleFactor),
		      1.0 * (1.0 + layer.scaleFactor),
		      1.0 * (1.0 + layer.scaleFactor)
		    );

		    if (Config.JITTER_PROBABILITY.value > 0) {
		      _.forEach(layer.children, function(ellipse) {
		        ellipse.geometry.verticesNeedUpdate = true;
		        _.forEach(ellipse.geometry.vertices, function(v) {
		          if (Math.random() < Config.JITTER_PROBABILITY.value) {
		            v.x = v.xOriginal + layerConfig.radius * Math.random() * Config.JITTER_INTENSITY.value;
		            v.y = v.yOriginal + layerConfig.radius * Math.random() * Config.JITTER_INTENSITY.value;
		            v.z = v.zOriginal + layerConfig.radius * Math.random() * Config.JITTER_INTENSITY.value;
		          }
		        });
		      });
		    }
		  });

		  renderer.render(scene, camera);
		}

		function encodeConfig(config) {
		  const values = {};
		  _.forEach(_.keys(config), function(key) {
		    values[key] = config[key].value;
		  });
		  return btoa(JSON.stringify(values));
		}

		function decodeConfig(base64) {
		  const values = JSON.parse(atob(base64));
		  _.forEach(_.keys(values), function(key) {
		    if (Config[key] != null) {
		      Config[key].value = values[key];
		    }
		  });
		  return Config;
		}

		$(document).ready(function() {
			console.log('************************************')
			console.log('Hello there! Have a job for me?\nPlease get in touch:\ndmitriy.borodiy@gmail.com');
			console.log('************************************')

		  $('#loading').hide();
		  $('#controls-info')
		    .css('opacity', 0.0)
		    .show()
		    .animate({ opacity: 1.0 }, 3000);
		  setTimeout(function() { 
		    $('#controls-info').animate({ opacity: 0 }, 3000);
		  }, 3000);

		  if (window.location.hash) {
		    try {
		      Config = decodeConfig(window.location.hash.substr(1));
		      recreateScene();
		    } catch (err) {
		      console.error(err);
		    }
		  }

		  init();
		});
  </script>

</body>
</html>
